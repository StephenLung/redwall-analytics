---
title: Exploring Big MT Cars with Python datatable and plotnine-Part 1
author: David Lucey
date: '2020-05-07'
slug: exploring-big-mt-cars-with-python-datatable-and-plotnine-part-1
categories: ["R", "Code-Oriented"]
tags: ["data.table", "datatable", "plotnine", "reticulate"]
output:
  html_document:
    code_folding: 'hide'
---



<pre class="r"><code># R Libraries
library(&quot;reticulate&quot;)
library(&quot;skimr&quot;)

knitr::opts_chunk$set(
  fig.width = 15,
  fig.height = 8,
  out.width = &#39;100%&#39;)</code></pre>
<pre class="r"><code># Choose Python 3.7 miniconda
reticulate::use_condaenv(
  condaenv = &quot;datatable&quot;,
  conda = &quot;/Users/davidlucey/opt/anaconda3/bin/conda&quot;,
  required = TRUE
  )</code></pre>
<pre class="r"><code># Install Python packages
lapply(c(&quot;plotnine&quot;, &quot;datatable&quot;), function(package) {
       conda_install(&quot;datatable&quot;, package, pip = TRUE)
})</code></pre>
<pre class="python"><code># Python libraries
import datatable as dt
from datatable import *
import numpy as np
import re
import pprint</code></pre>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>As mentioned in our last series <a href="https://redwallanalytics.com/2020/03/31/parsing-mass-municipal-pdf-cafrs-with-tabulizer-pdftools-and-aws-textract-part-1/">Parsing Mass Municipal PDF CAFRs with Tabulizer, pdftools and AWS Textract - Part 1</a> and <a href="https://redwallanalytics.com/2020/02/18/a-walk-though-of-accessing-financial-statements-with-xbrl-in-r-part-1/">A Walk Though of Accessing Financial Statements with XBRL in R - Part 1</a>, this is a year of clean-up. Redwall Analytics is going through this year, and solving problems previously encountered, but beyond our capabilities at the time. It is doing this by combining R and Python tools via <code>reticulate</code>, as we did with our series on <code>pdftools</code>, <code>tabulizer</code> and AWS <code>Textract</code>. Although we have worked with some Python, we have been hoping to leveraging the familiar syntax of two of our favorite R libraries, <code>data.table</code> and <code>ggplot2</code> to bridge our way into the language.</p>
<p>Python’s <code>datatable</code> was launched by <code>h2o</code> two years ago and is still in alpha stage with cautions that it may still be unstable and features may be missing or incomplete. We found that it feels very similar to the R version, with a few syntax differences and also some important pieces still to be added (as we will discuss). We could only find a handful of posts showing how to use <code>datatable</code>, and many of the examples we were probably not written by regular users of R <code>data.table</code>, and were often focused on its efficiency and ability to scale relative to <code>pandas</code>. We use R <code>data.table</code> every day and love the speed and concise syntax, so this walk-through analysis of the EPA’s Big MT cars data set will be on the syntax of the most frequent actual data exploration operations. As for <code>plotnine</code>, it feels more seamless with <code>ggplot2</code> with a few problems formatting plots in Rmarkdown.</p>
</div>
<div id="epas-big-mt-dataset" class="section level1">
<h1>EPA’s Big MT Dataset</h1>
<p>To make it a little interesting, we will use the <a href="%22https://github.com/rfordatascience/tidytuesday/tree/master/data/2019/2019-10-15%22">Tidy Tuesday Big MT Cars</a> with 36 years of 42,230 new US car models. The data dictionary with 83 variables describing each annual new car model is found <a href="https://www.fueleconomy.gov/feg/ws/index.shtml#fuelType1">here</a>. Everyone loves cars and remembering historical models, and we have naturally been curious about this data set. After closer analysis however, we discovered that there are some unfortunate missing pieces.</p>
<p>When we have modeled <code>mtcars</code>, weight (<code>wt</code>) and horsepower (<code>hp</code>), and their interaction, have been most informative for predicting <code>mpg</code>. It would have been interesting to look at the evolution of the <code>mtcars</code> coefficients over time, but these variables are not unfortunately not available. In addition, it is hard to get a sense of fleet mileage without the annual unit-volume of each new car model. Because of this, it is impossible to know the evolution of more fuel efficient electric vehicles relative to more fuel-hungry model sales.</p>
<p>It is difficult to understand why these variables are not included when that information must be available to the EPA, and it clearly says on page 6 of <a href="https://www.fueleconomy.gov/feg/pdfs/guides/FEG2020.pdf">Fuel Economy Guide 2020</a> that an extra 100 lbs decreases fuel economy by 1%. While the data set is still of interest to practice for data cleaning, it doesn’t look likely that we will be able replicate <code>mtcars</code> over time unless we can find more variables.</p>
</div>
<div id="loading-data-with-fread" class="section level1">
<h1>Loading Data with fread</h1>
<p>We tried to download both the origin zipped data directly from the EPA website (see link below), and the .csv from the Tidy Tuesday website, but were unsuccessful in both cases using Python and R versions of <code>fread</code>. We were able to download the Tidy Tuesday .csv link with <code>fread</code> in <code>data.table</code> but not <code>datatable</code>, and the error message didn’t give us enough information to figure it out. The documentation for <code>data.table</code> <code>fread</code> is among the most extensive of any function we know, while still thin for <code>datatable's</code> version so far. In the end, we manually downloaded and unzipped the file from the EPA’s website, and uploaded from our local drive.</p>
<pre class="python"><code># Data dictionary, EPA vehicles zip and Tidy Tuesday vehicles csv links
#Data dictionary https://www.fueleconomy.gov/feg/ws/index.shtml#fuelType1
#EPA zip data set https://www.fueleconomy.gov/feg/epadata/vehicles.csv.zip
#Tidy Tuesday csv data set https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-10-15/big_epa_cars.csv

# Load vehicles
big_mt = fread(&quot;~/Desktop/David/Projects/general_working/mt_cars/vehicles.csv&quot;)

# Dimensions
big_mt.shape</code></pre>
<pre><code>## (42230, 83)</code></pre>
<p>The list of all 83 variables below, and we can see that there are several pertaining to fuel efficiency, emissions, fuel type, range, volume and some of the same attributes that we all know from <code>mtcars</code> (ie: cylinders, displacement, make, model and transmission). As mentioned, gross horsepower and weight are missing, but carburetors, acceleration and engine shape are also absent. We have all classes of vehicles sold, so get vehicle class information (<code>VClass</code>) not available in <code>mtcars</code> which is only cars. We will discuss further down, changes to the weight cutoffs on some of the categories over time make <code>VClass</code> of questionable use.</p>
<pre class="python"><code># Extract names as list for further processing in next chunk
names = [name for name in big_mt.names]

# Set up pprint params and print
pp = pprint.PrettyPrinter(width=80, compact = True)
pp.pprint(names)</code></pre>
<pre><code>## [&#39;barrels08&#39;, &#39;barrelsA08&#39;, &#39;charge120&#39;, &#39;charge240&#39;, &#39;city08&#39;, &#39;city08U&#39;,
##  &#39;cityA08&#39;, &#39;cityA08U&#39;, &#39;cityCD&#39;, &#39;cityE&#39;, &#39;cityUF&#39;, &#39;co2&#39;, &#39;co2A&#39;,
##  &#39;co2TailpipeAGpm&#39;, &#39;co2TailpipeGpm&#39;, &#39;comb08&#39;, &#39;comb08U&#39;, &#39;combA08&#39;,
##  &#39;combA08U&#39;, &#39;combE&#39;, &#39;combinedCD&#39;, &#39;combinedUF&#39;, &#39;cylinders&#39;, &#39;displ&#39;, &#39;drive&#39;,
##  &#39;engId&#39;, &#39;eng_dscr&#39;, &#39;feScore&#39;, &#39;fuelCost08&#39;, &#39;fuelCostA08&#39;, &#39;fuelType&#39;,
##  &#39;fuelType1&#39;, &#39;ghgScore&#39;, &#39;ghgScoreA&#39;, &#39;highway08&#39;, &#39;highway08U&#39;, &#39;highwayA08&#39;,
##  &#39;highwayA08U&#39;, &#39;highwayCD&#39;, &#39;highwayE&#39;, &#39;highwayUF&#39;, &#39;hlv&#39;, &#39;hpv&#39;, &#39;id&#39;, &#39;lv2&#39;,
##  &#39;lv4&#39;, &#39;make&#39;, &#39;model&#39;, &#39;mpgData&#39;, &#39;phevBlended&#39;, &#39;pv2&#39;, &#39;pv4&#39;, &#39;range&#39;,
##  &#39;rangeCity&#39;, &#39;rangeCityA&#39;, &#39;rangeHwy&#39;, &#39;rangeHwyA&#39;, &#39;trany&#39;, &#39;UCity&#39;, &#39;UCityA&#39;,
##  &#39;UHighway&#39;, &#39;UHighwayA&#39;, &#39;VClass&#39;, &#39;year&#39;, &#39;youSaveSpend&#39;, &#39;guzzler&#39;,
##  &#39;trans_dscr&#39;, &#39;tCharger&#39;, &#39;sCharger&#39;, &#39;atvType&#39;, &#39;fuelType2&#39;, &#39;rangeA&#39;,
##  &#39;evMotor&#39;, &#39;mfrCode&#39;, &#39;c240Dscr&#39;, &#39;charge240b&#39;, &#39;c240bDscr&#39;, &#39;createdOn&#39;,
##  &#39;modifiedOn&#39;, &#39;startStop&#39;, &#39;phevCity&#39;, &#39;phevHwy&#39;, &#39;phevComb&#39;]</code></pre>
</div>
<div id="set-up-thoughts-from-r-perspective" class="section level1">
<h1>Set-up Thoughts from R Perspective</h1>
<p>There were a couple of things about the set-up for <code>datatable</code>, which weren’t apparent coming over from <code>data.table</code> as an R user. The first was to use <code>from dt import *</code> at the outset to avoid having to reference the package short name every time within the frame. The second was to use <code>export_names()</code> in order to skip having to use the <code>f</code> operator or quotation marks to reference variables. In order to do this, we had to create a dictionary of names using the <code>names</code> list from above, and each of their <code>f</code> expressions extracted with <code>export_names</code> in a second list. We then used update from the local environment to assign all of the dictionary values to their keys as variables. From then on, we can refer to those variable without quotation marks or the <code>f</code> operator (although any new variables created would still need <code>f</code> or quotation marks). We weren’t sure why this is not the default behavior, but it is easily worked around. These two steps brought the feel of <code>datatable</code> a lot closer to the usual R <code>data.table</code> (ie: without the package and expression short codes).</p>
</div>
<div id="basic-filter-and-select-operations" class="section level1">
<h1>Basic Filter and Select Operations</h1>
<p>A few lines of some key variables are shown in the code below, and it is clear that they need significant cleaning to be of use. One difference with R <code>data.table</code> can be seen below with filtering. Using our <code>year_filter</code> in <code>i</code> (the first slot), the 1204 2019 models are shown below. Unlike R <code>data.table</code>, we refer to <code>year</code> outside of the frame in an expression, and then call it within <code>i</code> of the frame. The columns can be selected within <code>()</code> or <code>[]</code> in <code>j</code> (the second slot) as shown below, and new columns can be created within <code>{}</code>.</p>
<pre class="python"><code># Key variables for year 2019
year_filter = (year == 2020)
print(big_mt[year_filter, (year, make, model, trany, evMotor, VClass)])</code></pre>
<pre><code>##      | year  make     model                        trany                             evMotor             VClass                            
## ---- + ----  -------  ---------------------------  --------------------------------  ------------------  ----------------------------------
##    0 | 2020  Toyota   Corolla                      Automatic (AV-S10)                                    Compact Cars                      
##    1 | 2020  Toyota   Corolla Hybrid               Automatic (variable gear ratios)  202V Ni-MH          Compact Cars                      
##    2 | 2020  Toyota   Corolla                      Manual 6-spd                                          Compact Cars                      
##    3 | 2020  Toyota   Corolla XSE                  Automatic (AV-S10)                                    Compact Cars                      
##    4 | 2020  Toyota   Corolla                      Automatic (variable gear ratios)                      Compact Cars                      
##    5 | 2020  Toyota   Corolla                      Manual 6-spd                                          Compact Cars                      
##    6 | 2020  Toyota   Corolla XLE                  Automatic (variable gear ratios)                      Compact Cars                      
##    7 | 2020  Kia      Soul                         Automatic (variable gear ratios)                      Small Station Wagons              
##    8 | 2020  Kia      Soul Eco dynamics            Automatic (variable gear ratios)                      Small Station Wagons              
##    9 | 2020  Kia      Soul                         Manual 6-spd                                          Small Station Wagons              
##   10 | 2020  Kia      Soul                         Automatic (AM-S7)                                     Small Station Wagons              
##   11 | 2020  Kia      Sportage FWD                 Automatic (S6)                                        Small Sport Utility Vehicle 2WD   
##   12 | 2020  Kia      Sportage FWD                 Automatic (S6)                                        Small Sport Utility Vehicle 2WD   
##   13 | 2020  Kia      Telluride FWD                Automatic (S8)                                        Small Sport Utility Vehicle 2WD   
##   14 | 2020  Kia      Sportage AWD                 Automatic (S6)                                        Small Sport Utility Vehicle 4WD   
##    … |    …  …        …                            …                                 …                   …                                 
## 1199 | 2020  Porsche  718 Cayman GT4               Manual 6-spd                                          Two Seaters                       
## 1200 | 2020  Bentley  Mulsanne                     Automatic (S8)                                        Midsize Cars                      
## 1201 | 2020  Porsche  Cayenne e-Hybrid             Automatic (S8)                    99 kW DC Brushless  Standard Sport Utility Vehicle 4WD
## 1202 | 2020  Porsche  Cayenne e-Hybrid Coupe       Automatic (S8)                    99 kW DC Brushless  Standard Sport Utility Vehicle 4WD
## 1203 | 2020  Porsche  Taycan 4S Perf Battery Plus  Automatic (A2)                    120 kW ACPM         Large Cars                        
## 
## [1204 rows x 6 columns]</code></pre>
<p>We usually like to make a quick check if there are any duplicated rows across the whole our dataFrame, but there isn’t a duplicated() function yet in <code>datatable</code>. According to <a href="https://stackoverflow.com/questions/61578175/how-to-find-unique-values-for-a-field-in-pydatatable-data-frame">How to find unique values for a field in Pydatatable Data Frame</a>, the <code>unique()</code> function also doesn’t apply to groups yet. In order to work around this, identifying variables would have to be grouped, counted and filtered for equal to 1, but we weren’t sure yet exactly which variables to group on. We decided to pipe over to <code>pandas</code> to verify with a simple line of code that there were no duplicates, but hope this function will be added in the future.</p>
</div>
<div id="aggregate-new-variable-and-sort" class="section level1">
<h1>Aggregate New Variable and Sort</h1>
<p>We can see that below that ‘eng_dscr’ is unfortunately blank 38% of the time, and high cardinality for the rest of the levels. A small percentage are marked “GUZZLER” and “FLEX FUELS”. in a few cases, potentially helpful information about engine like V-6 or V-8 are included with very low frequency, but not consistently enough to make sense try to extract. Another potentially informative variable, <code>trans_dscr</code> is similarly blank more than 60% of the time. It seems unlikely that we could clean these up to make it useful in an analysis, so will probably have to drop them.</p>
<pre class="python"><code>print(big_mt[:, {&#39;percent&#39; : int32(count() * 100/big_mt.nrows) }, by(eng_dscr)]\
            [:,:, sort(-f.percent)])</code></pre>
<pre><code>##     | eng_dscr                      percent
## --- + ----------------------------  -------
##   0 |                                    38
##   1 | (FFS)                              20
##   2 | SIDI                               14
##   3 | (FFS) CA model                      2
##   4 | (FFS)      (MPFI)                   1
##   5 | (FFS,TRBO)                          1
##   6 | FFV                                 1
##   7 | (121)      (FFS)                    0
##   8 | (122)      (FFS)                    0
##   9 | (16 VALVE) (FFS)      (MPFI)        0
##  10 | (16-VALVE) (FFS)                    0
##  11 | (16-VALVE) (FFS)      (MPFI)        0
##  12 | (16-VALVE) (FFS,TRBO)               0
##  13 | (164S)     (FFS)      (MPFI)        0
##  14 | (16VALVES) (FFS)                    0
##   … | …                                   …
## 556 | VTEC       (FFS)                    0
## 557 | VTEC-E                              0
## 558 | VTEC-E     (FFS)                    0
## 559 | Z/28                                0
## 560 | new body style                      0
## 
## [561 rows x 2 columns]</code></pre>
</div>
<div id="separate-and-assign-new-variables" class="section level1">
<h1>Separate and Assign New Variables</h1>
<p>As shown above, <code>trany</code> has both the transmission-type and gear-speed variables within it, so we extracted the variable from big_mt with <code>to_list()</code>, drilled down one level, and used regex to extract the transmission and gear information needed out into <code>trans</code> and <code>gear</code>. Notice that we needed to convert the lists back into columns with dt.Frame before assigning as new variables in big_mt.</p>
<p>In the third line of code, we felt like we were using an R <code>data.table</code>. The <code>{}</code> is used group by <code>trans</code> and <code>gear</code>, and then to create the new <code>percent</code> variable in-line, without affecting the other variables in big_mt. We tried to round the decimals in percent, but couldn’t figure it out so far. Our understanding is that there is no <code>round()</code> method yet for <code>datatable</code>, so we multiplied by 100 and converted to integer. We again called <code>export_names()</code>, to be consistent in using non-standard evaluation with the two new variables.</p>
<pre class="python"><code>big_mt[&#39;trans&#39;] = dt.Frame([re.sub(&#39;[\s\(].*$&#39;,&#39;&#39;, s) for s in big_mt[:, &#39;trany&#39;].to_list()[0]])
big_mt[&#39;gear&#39;] = dt.Frame([re.sub(&#39;A\w+\s|M\w+\s&#39;,&#39;&#39;, s) for s in big_mt[:, &#39;trany&#39;].to_list()[0]])
gear, trans= big_mt[:, (&#39;gear&#39;, &#39;trans&#39;)].export_names()

# Summarize percent of instances by transmission and speed
print(big_mt[:, { &#39;percent&#39; : int32(count() * 100 /big_mt.nrows) }, by(trans, gear)]\
            [0:13, : , sort(-f.percent)])</code></pre>
<pre><code>##    | trans      gear                    percent
## -- + ---------  ----------------------  -------
##  0 | Automatic  4-spd                        26
##  1 | Manual     5-spd                        19
##  2 | Automatic  (S6)                          7
##  3 | Automatic  3-spd                         7
##  4 | Manual     6-spd                         6
##  5 | Automatic  5-spd                         5
##  6 | Automatic  (S8)                          4
##  7 | Automatic  6-spd                         3
##  8 | Manual     4-spd                         3
##  9 | Automatic  (variable gear ratios)        2
## 10 | Automatic  (AM-S7)                       1
## 11 | Automatic  (S5)                          1
## 12 | Automatic  7-spd                         1
## 
## [13 rows x 3 columns]</code></pre>
</div>
<div id="set-key-and-join" class="section level1">
<h1>Set Key and Join</h1>
<p>We wanted to create a Boolean variable to denote if a vehicle had an electric motor or not. We again used <code>{}</code> to create the variable in the frame, but don’t think it is possible to update by reference so still had to assign to <code>is_ev</code>. In the table below, we show the number of electric vehicles rising from 3 in 1998 to 149 this year. Unfortunately,</p>
<pre class="python"><code># Create &#39;is_ev&#39; within the frame
big_mt[&#39;is_ev&#39;] = big_mt[:, { &#39;is_ev&#39; : evMotor != &#39;&#39; }]
is_ev = big_mt[:, &#39;is_ev&#39;].export_names()
ann_models = big_mt[:, {&#39;all_models&#39; : count()}, by(year)]
ev_models = big_mt[:, {&#39;ev_models&#39; : count() }, by(&#39;year&#39;, &#39;is_ev&#39;)]\
                  [(f.is_ev == 1), (&#39;year&#39;, &#39;ev_models&#39;)]
ev_models.key = &quot;year&quot;
print(ann_models[:, :, join(ev_models)]\
                [:, { &#39;all_models&#39; : f.all_models, 
                      &#39;ev_models&#39; : f.ev_models, 
                      &#39;percent&#39; : int32(f.ev_models * 100 / f.all_models) }, 
                      by(year)]\
                [(year &gt; 1996), :])</code></pre>
<pre><code>##    | year  all_models  ev_models  percent
## -- + ----  ----------  ---------  -------
##  0 | 1997         762         NA       NA
##  1 | 1998         812          3        0
##  2 | 1999         852          7        0
##  3 | 2000         840          4        0
##  4 | 2001         911          5        0
##  5 | 2002         975          2        0
##  6 | 2003        1044          1        0
##  7 | 2004        1122         NA       NA
##  8 | 2005        1166         NA       NA
##  9 | 2006        1104         NA       NA
## 10 | 2007        1126         NA       NA
## 11 | 2008        1187         23        1
## 12 | 2009        1184         27        2
## 13 | 2010        1109         34        3
## 14 | 2011        1130         49        4
## 15 | 2012        1152         55        4
## 16 | 2013        1184         68        5
## 17 | 2014        1225         77        6
## 18 | 2015        1283         76        5
## 19 | 2016        1262         95        7
## 20 | 2017        1293         92        7
## 21 | 2018        1344        103        7
## 22 | 2019        1335        133        9
## 23 | 2020        1204        149       12
## 24 | 2021          73          6        8
## 
## [25 rows x 4 columns]</code></pre>
</div>
<div id="using-regular-expressions-in-row-operations" class="section level1">
<h1>Using Regular Expressions in Row Operations</h1>
<p>Next, we hoped to extract wheel-drive (2WD, AWD, 4WD, etc) and engine type (ie: V4, V6, etc) from <code>model</code>. The <code>re_match()</code> function is helpful in filtering rows in <code>i</code>. As shown below, we found almost 17k matches for wheel drive, but only 718 for the engine size. Given that we have over 42k rows, we will extract the wheels and give up on the engine data. It still may not be enough data for <code>wheels</code> to be a helpful variable.</p>
<pre class="python"><code># Regex match with re_match()
print(&#39;%d of rows with wheels info.&#39; % (big_mt[model.re_match(&#39;.*(.WD).*&#39;), model].nrows))</code></pre>
<pre><code>## 16921 of rows with wheels info.</code></pre>
<pre class="python"><code>print(&#39;%d of rows with engine info.&#39; % (big_mt[model.re_match(&#39;.*(V|v)(\s|\-)?\d+.*&#39;), model].nrows))</code></pre>
<pre><code>## 718 of rows with engine info.</code></pre>
<p>We used regex to extract whether the model was 2WD, 4WD, etc as <code>wheels</code> from <code>model</code>, but most of the time, it was the same information as we already had in <code>drive</code>. It is possible that our weakness in Python is at play, but this would have been a lot simpler in R, because we wouldn’t have iterated over every row in order to extract part of the row with regex. We found that there were some cases where the 2WD and 4WD were recorded as 2wd and 4wd. The <code>replace()</code> function was an efficient solution to this problem, replacing matches of ‘wd’ with ‘WD’ over the entire frame.</p>
<pre class="python"><code># Extract &#39;wheels&#39; and &#39;engine&#39; from &#39;model&#39;
reg = re.compile(r&#39;(.*)(.WD|4x4)(.*)&#39;, re.IGNORECASE)
big_mt[:, &#39;wheels&#39;] = dt.Frame([reg.match(s).group(2) if reg.search(s) else &#39;&#39; for s in big_mt[:, model].to_list()[0]])
wheels = big_mt[:, &#39;wheels&#39;].export_names()

# Fix problem notations
big_mt.replace(&quot;\dwd&quot;, &quot;\dWD&quot;)

# Summarize total count for all years
cols = [&#39;make&#39;, &#39;model&#39;, &#39;cylinders&#39;, &#39;wheels&#39;, &#39;drive&#39;]
print(big_mt[(f.wheels != &#39;&#39;), cols]\
            [:, count(), by(f.wheels, cylinders, drive)]\
            [0:14:, :, sort(-f.count)])</code></pre>
<pre><code>##    | wheels  cylinders  drive                       count
## -- + ------  ---------  --------------------------  -----
##  0 | 2WD             8  Rear-Wheel Drive             2616
##  1 | 2WD             6  Rear-Wheel Drive             2255
##  2 | 4WD             6  4-Wheel or All-Wheel Drive   1637
##  3 | 4WD             8  4-Wheel or All-Wheel Drive   1481
##  4 | 2WD             4  Rear-Wheel Drive             1063
##  5 | 4WD             4  4-Wheel or All-Wheel Drive    984
##  6 | AWD             6  All-Wheel Drive               771
##  7 | FWD             4  Front-Wheel Drive             638
##  8 | AWD             4  All-Wheel Drive               629
##  9 | 2WD             4  Front-Wheel Drive             508
## 10 | FWD             6  Front-Wheel Drive             497
## 11 | 2WD             6  Front-Wheel Drive             416
## 12 | AWD             4  4-Wheel or All-Wheel Drive    368
## 13 | 4WD             8  4-Wheel Drive                 361
## 
## [14 rows x 4 columns]</code></pre>
</div>
<div id="reshaping" class="section level1">
<h1>Reshaping</h1>
<p>There was no such thing as an 4-wheel drive SUVs back in the 80’s, and we remember the big 8-cylinder Oldsmobiles and Cadillacs, so were curious how these models evolved over time. <code>datatable</code> doesn’t yet have dcast() or melt(), so we had to pipe these out <code>to_pandas()</code> and then use <code>pivot_table()</code>. Its likely that a lot of the the many models where wheel-drive was unspecified were 2WD, which is still the majority of models. We would have liked to show these as whole numbers, and there is a workaround in <code>datatable</code> to convert to integer, but once we pivoted in <code>pandas</code>, it reverted to float. We can see the first AWD models starting in the late 80s, and the number of 8-cylinder cars fall by half. There are are a lot fewer annual new car models now than in the 80s, but were surprised how many fewer 4-cylinders.</p>
<pre class="python"><code># Summarize by year again having to move to pandas to pivot
print(big_mt[:, count(), by(f.wheels, year)].to_pandas().pivot_table(index=&#39;wheels&#39;, columns=&#39;year&#39;, values=&#39;count&#39;))</code></pre>
<pre><code>## year      1984    1985   1986   1987   1988  ...   2017   2018   2019   2020  2021
## wheels                                       ...                                  
##         1184.0  1057.0  698.0  732.0  677.0  ...  798.0  821.0  797.0  706.0  46.0
## 2WD      472.0   430.0  338.0  310.0  262.0  ...   89.0   97.0  110.0   94.0   4.0
## 4WD      304.0   208.0  174.0  201.0  187.0  ...  107.0  119.0  131.0  131.0   5.0
## 4x4        NaN     NaN    NaN    2.0    2.0  ...    1.0    1.0    NaN    NaN   NaN
## AWD        NaN     NaN    NaN    2.0    2.0  ...  186.0  197.0  195.0  180.0  10.0
## FWD        1.0     4.0    NaN    NaN    NaN  ...  104.0   96.0   88.0   78.0   5.0
## RWD        3.0     2.0    NaN    NaN    NaN  ...    8.0   13.0   14.0   15.0   3.0
## 
## [7 rows x 38 columns]</code></pre>
<pre class="python"><code>print(big_mt[:, count(), by(cylinders, year)].to_pandas().pivot_table(index=&#39;cylinders&#39;, columns=&#39;year&#39;, values=&#39;count&#39;))</code></pre>
<pre><code>## year         1984   1985   1986   1987   1988  ...   2017   2018   2019   2020  2021
## cylinders                                      ...                                  
## 2.0           6.0    5.0    1.0    3.0    3.0  ...    1.0    2.0    2.0    2.0   NaN
## 3.0           NaN    6.0    9.0   11.0   13.0  ...   26.0   22.0   22.0   19.0   7.0
## 4.0        1020.0  853.0  592.0  625.0  526.0  ...  563.0  590.0  585.0  523.0  44.0
## 5.0          39.0   20.0   18.0   26.0   17.0  ...    1.0    2.0    2.0    2.0   NaN
## 6.0         457.0  462.0  323.0  296.0  325.0  ...  416.0  449.0  440.0  374.0  17.0
## 8.0         439.0  351.0  263.0  282.0  241.0  ...  211.0  219.0  224.0  222.0   4.0
## 10.0          NaN    NaN    NaN    NaN    NaN  ...    7.0    8.0    4.0    6.0   NaN
## 12.0          3.0    2.0    3.0    4.0    5.0  ...   38.0   27.0   20.0   21.0   1.0
## 16.0          NaN    NaN    NaN    NaN    NaN  ...    NaN    1.0    1.0    1.0   NaN
## 
## [9 rows x 38 columns]</code></pre>
</div>
<div id="combining-levels-of-variables-with-high-cardinality" class="section level1">
<h1>Combining Levels of Variables with High Cardinality</h1>
<p>With 35 distinct levels often referring to similar vehicles, <code>VClass</code> also needed to be cleaned up. Even in R <code>data.table</code>, we have been keenly awaiting the implemention of <code>fcase</code>, which is expected to replicate the <code>dplyr</code> <code>case_when()</code> function for nested control-flow statements. We made a separate 16-line function to lump factor levels (not shown). In the first line below, we created the <code>vclasses</code> list to drill down on the <code>VClass</code> tuple elements as strings. In the second line, we had to iterate over the resulting strings from the 0-index of the tuple to extract wheel-drive from a list-comprehension. We printed out the result of our much smaller list of lumped factors, but there are still problems with the result. The EPA changed the cutoff for a “Small Pickup Truck” from 4,500 to 6,000 lbs in 2008, and also used a higher cut-off for “small” SUV’s starting in 2011. This will make it pretty hard to us VClass as a consistent variable for modeling, at least for Pickups and SUVs. As noted earlier, if we had the a weight field, we could have easily worked around this.</p>
<pre class="python"><code># Clean up vehicle type from VClass
vclasses = [tup[0] for tup in big_mt[:, &#39;VClass&#39;].to_tuples()]
big_mt[&#39;VClass&#39;] = dt.Frame([re.sub(&#39;\s\dWD$|\/\dwd$|\s\-\s\dWD$&#39;, &#39;&#39;, x) if re.search(r&#39;WD$|wd$&#39;, x) is not None else x for x in vclasses])
big_mt[&#39;VClass&#39;] = dt.Frame([collapse_vclass(line[0]) for line in big_mt[:, &#39;VClass&#39;].to_tuples()])

# Show final VClass types
print(dt.unique(big_mt[&quot;VClass&quot;]))</code></pre>
<pre><code>##    | VClass                 
## -- + -----------------------
##  0 | Large Car              
##  1 | Midsize Car            
##  2 | Minivan                
##  3 | Small Car              
##  4 | Small Pickup and SUV   
##  5 | Special Purpose Vehicle
##  6 | Sport Utility Vehicle  
##  7 | Standard Pickup Trucks 
##  8 | Vans                   
## 
## [9 rows x 1 column]</code></pre>
</div>
<div id="selecting-multiple-columns-with-regex" class="section level1">
<h1>Selecting Multiple Columns with Regex</h1>
<p>In the chunk (below), we show how to select columns from the big_mt names tuple by creating the <code>measures</code> selector using regex matches for the key identifier columns and for integer mileage columns matching ‘08’. This seemed complicated and we couldn’t do it in line within the frame as we would have with <code>data.table</code> .SD = patterns(). We also wanted to reorder to move the identifier columns (<code>year</code>, <code>make</code> and <code>model</code>) to the left side of the table, but couldn’t find a equivalent <code>setcolorder</code> function. There is documentation about multi-column selection, but we couldn’t figure out an efficient way to make it work. We show the frame with the <code>year_filter</code> which we set up earlier.</p>
<pre class="python"><code># Regex search for variable selection
measures = [x for x in big_mt.names if re.search(r&#39;make|model|year|08$&#39;, x)]

# Print remaining cols with measures filter
print(big_mt[year_filter,  measures])</code></pre>
<pre><code>##      | barrels08  barrelsA08  city08  cityA08  comb08  combA08  fuelCost08  fuelCostA08  highway08  highwayA08  make     model                        year
## ---- + ---------  ----------  ------  -------  ------  -------  ----------  -----------  ---------  ----------  -------  ---------------------------  ----
##    0 |   9.69441       0          31        0      34        0         800            0         40           0  Toyota   Corolla                      2020
##    1 |   6.33865       0          53        0      52        0         500            0         52           0  Toyota   Corolla Hybrid               2020
##    2 |  10.3003        0          29        0      32        0         850            0         36           0  Toyota   Corolla                      2020
##    3 |   9.69441       0          31        0      34        0         800            0         38           0  Toyota   Corolla XSE                  2020
##    4 |   9.98818       0          30        0      33        0         800            0         38           0  Toyota   Corolla                      2020
##    5 |   9.98818       0          29        0      33        0         800            0         39           0  Toyota   Corolla                      2020
##    6 |  10.3003        0          29        0      32        0         850            0         37           0  Toyota   Corolla XLE                  2020
##    7 |  10.987         0          27        0      30        0         900            0         33           0  Kia      Soul                         2020
##    8 |  10.6326        0          29        0      31        0         900            0         35           0  Kia      Soul Eco dynamics            2020
##    9 |  12.2078        0          25        0      27        0        1000            0         31           0  Kia      Soul                         2020
##   10 |  11.3659        0          27        0      29        0         950            0         32           0  Kia      Soul                         2020
##   11 |  12.6773        0          23        0      26        0        1050            0         30           0  Kia      Sportage FWD                 2020
##   12 |  14.3309        0          20        0      23        0        1200            0         28           0  Kia      Sportage FWD                 2020
##   13 |  14.3309        0          20        0      23        0        1200            0         26           0  Kia      Telluride FWD                2020
##   14 |  14.3309        0          22        0      23        0        1200            0         26           0  Kia      Sportage AWD                 2020
##    … |         …           …       …        …       …        …           …            …          …           …  …        …                               …
## 1199 |  17.3479        0          16        0      19        0        2000            0         23           0  Porsche  718 Cayman GT4               2020
## 1200 |  27.4675        0          10        0      12        0        3150            0         16           0  Bentley  Mulsanne                     2020
## 1201 |  10.5064        0.426      20       45      21       41        1800         1400         22          37  Porsche  Cayenne e-Hybrid             2020
## 1202 |  10.5064        0.426      20       45      21       41        1800         1400         22          37  Porsche  Cayenne e-Hybrid Coupe       2020
## 1203 |   0.294         0          68        0      69        0         950            0         71           0  Porsche  Taycan 4S Perf Battery Plus  2020
## 
## [1204 rows x 13 columns]</code></pre>
</div>
<div id="selecting-columns-and-exploring-summary-data" class="section level1">
<h1>Selecting Columns and Exploring Summary Data</h1>
<p>We looked for a Python version of <code>skimr</code>, but it doesn’t seem like there is an similar library (as is often the case). We tried out <code>pandas profiling</code>, but that had a lot of dependencies and seemed like overkill for our purposes, so decided to use <code>skim_tee</code> on the table in a separate R chunk (below). It was necessary to convert to <code>pandas</code> in the Python chunk (above), because we couldn’t figure out how to translate a <code>datatable</code> back to a data.frame via <code>reticulate</code> in the R chunk.</p>
<p>When we did convert, we discovered there were some problems mapping NA’s which we will show below. We suspect it isn’t possible to pass a <code>datatable</code> to <code>data.table</code>, and this might be the first functionality we would vote to add. There is a sizable community of <code>data.table</code> users who are used to the syntax, and as we are, might be looking to port into Python (rather than learn <code>pandas</code> directly). As <code>reticulate</code> develops, opening this door seems to make so much sense.
Below, we again run <code>export_names()</code> in order to also prepare the newly generated variables for non-standard evaluation within the frame, and then filtered for the 21 columns we wanted to keep.</p>
<pre class="python"><code># List of cols to keep
cols = [&#39;make&#39;, 
        &#39;model&#39;, 
        &#39;year&#39;, 
        &#39;city08&#39;, 
        &#39;highway08&#39;, 
        &#39;comb08&#39;, 
        &#39;VClass&#39;, 
        &#39;drive&#39;,
        &#39;fuelType1&#39;, 
        &#39;hlv&#39;, 
        &#39;hpv&#39;, 
        &#39;cylinders&#39;, 
        &#39;displ&#39;,
        &#39;trans&#39;, 
        &#39;gear&#39;,
        &#39;wheels&#39;,
        &#39;is_ev&#39;,
        &#39;evMotor&#39;, 
        &#39;guzzler&#39;,
        &#39;tCharger&#39;,
        &#39;sCharger&#39;]

# Select cols and create pandas version
big_mt_pandas = big_mt[:, cols].to_pandas()</code></pre>
<pre class="r"><code># Skimr
skim_tee(py$big_mt_pandas)</code></pre>
<pre><code>## ── Data Summary ────────────────────────
##                            Values
## Name                       data  
## Number of rows             42230 
## Number of columns          21    
## _______________________          
## Column type frequency:           
##   character                12    
##   logical                  1     
##   numeric                  8     
## ________________________         
## Group variables            None  
## 
## ── Variable type: character ────────────────────────────────────────────────────
##    skim_variable n_missing complete_rate   min   max empty n_unique whitespace
##  1 make                  0             1     3    34     0      137          0
##  2 model                 0             1     1    47     0     4217          0
##  3 VClass                0             1     4    23     0        9          0
##  4 drive                 0             1     0    26  1189        8          0
##  5 fuelType1             0             1     6    17     0        6          0
##  6 trans                 0             1     0     9    11        3          0
##  7 gear                  0             1     0    22    11       34          0
##  8 wheels                0             1     0     3 25265        7          0
##  9 evMotor               0             1     0    51 41221      171          0
## 10 guzzler               0             1     0     1 39747        4          0
## 11 tCharger              0             1     0     1 34788        2          0
## 12 sCharger              0             1     0     1 41352        2          0
## 
## ── Variable type: logical ──────────────────────────────────────────────────────
##   skim_variable n_missing complete_rate   mean count                
## 1 is_ev                 0             1 0.0239 FAL: 41221, TRU: 1009
## 
## ── Variable type: numeric ──────────────────────────────────────────────────────
##   skim_variable n_missing complete_rate    mean    sd    p0    p25   p50    p75
## 1 year                  0         1     2002.   11.4   1984 1991    2003 2012  
## 2 city08                0         1       18.5   8.36     6   15      17   21  
## 3 highway08             0         1       24.6   8.03     9   20      24   28  
## 4 comb08                0         1       20.8   8.06     7   17      20   23  
## 5 hlv                   0         1        1.99  5.92     0    0       0    0  
## 6 hpv                   0         1       10.2  27.9      0    0       0    0  
## 7 cylinders           240         0.994    5.71  1.76     2    4       6    6  
## 8 displ               238         0.994    3.29  1.36     0    2.2     3    4.3
##     p100 hist 
## 1 2021   ▇▅▆▆▇
## 2  150   ▇▁▁▁▁
## 3  132   ▇▁▁▁▁
## 4  141   ▇▁▁▁▁
## 5   49   ▇▁▁▁▁
## 6  195   ▇▁▁▁▁
## 7   16   ▇▇▅▁▁
## 8    8.4 ▁▇▅▂▁</code></pre>
<p>In the result above, we see a lot of challenges if we had hoped to have appropriate data to build a model to predict mpg over time. Many variables, such as <code>evMotor</code>, <code>tCharger</code>, <code>sCharger</code> and <code>guzzler</code>, are only available in a small number of rows. When we set out on this series, we hoped we would be able to experiment with modeling gas mileage for every year just like <code>mtcars</code>, but that seems unlikely based on the available variables.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>It took us a couple of months to get up and running with R <code>data.table</code>, and even with daily usage, we are still learning its nuance a year later. We think the up-front investment in learning the syntax, which can be a little confusing at first, has been worth it. It is also less well documented than <code>dplyr</code> or <code>pandas</code>. We learned so much about <code>data.table</code> from a few blog posts such as <a href="http://brooksandrew.github.io/simpleblog/articles/advanced-data-table/">Advanced tips and tricks with data.table</a> and <a href="https://atrebas.github.io/post/2019-03-03-datatable-dplyr/">A data.table and dplyr tour</a>. The goal of this post is to help to similarly fill the gap for <code>datatable</code>.</p>
<p>Python <code>datatable</code> is promising, and we are grateful for it as familiar territory as we learn Python. We can’t tell how much of our difficulty has been because the package is not quite mature compared to the mature <code>data.table</code> or our just inexperience with Python. The need to manually set variables for non-standard evaluation, to revert to pandas to accomplish certain tasks (ie: reshaping) or the challenges extracting and filtering data from nested columns. It was still not easy to navigate the documentation and there were areas where the documentation was not Also, it would be appreciated to seamlessly translate between a <code>datatable</code> and <code>data.table</code>. In the next post, we will continue to use Big MT Cars data to try out <code>plotnine</code>, the Python version of <code>ggplot</code>.</p>
</div>
